---
title: "Summary stats, dimension reduction plots, clustering, HVGs, and heatmaps from Seurat workflow"
subtitle: '`r params$pair_ids`'
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 4
    toc_float: true

params:
  pair_ids: 'pair_ids'
  path_to_10X: 'path_to_10X'
  whichMethod: 'whichMethod' # to use different parameters here, just update them.
  min_features: 'min_features'
  mito_thresh_max: 'mito_thresh_max'
  mito_thresh_min: 'mito_thresh_min'
  ribo_thresh_max: 'ribo_thresh_max'
  nmads: 'nmads'
  remove_mito_and_ribo: 'remove_mito_and_ribo' # "yes" will remove all mito and ribo genes, "no" will retain them both in the sce
  dm_path: dm_path
  reporter_genes: 'reporter_genes'
  
---

In this document, we show summary statistics and results of quality control on the samples. The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features.  

While filtering low quality cells, we consider the following:  

* Total number of RNA reads detected in each cell  
* The number of unique genes detected in each cell:  
  + Low-quality cells or empty droplets will often have very few genes while cell doublets or multiplets may exhibit an aberrantly high gene count.  
* The percentage of reads that map to the mitochondrial genome:  
  + Low-quality / dying cells often exhibit extensive mitochondrial contamination. We restrict the mitochondrial content to 25% of all the reads.  
* The percentage of reads that map to ribosomal RNA:  
  + Ribosomal content is restricted to 60% per cell.  


```{css, echo=FALSE}
    body .main-container {
      max-width: 90% !important;
      width: 90% !important;
    }

    body {
      max-width: 90% !important;
    }
```

```{r include = FALSE}
# source the files for the functions we need 
library(here)
source(here('pipeline', 'sourceFiles', 'utilities.R'))
source(here('pipeline', 'process_qc_normalization', 'data_preparation', 'convert_to_sces.R'))
source(here('pipeline', 'process_qc_normalization', 'qc', 'default_qc.R'))

```

```{r include = FALSE}

# extract the name_list from the parameters. we use the name list later on while making graphs. 
ids <- strsplit(params$pair_ids, "[-/ ]")[[1]] # split by "-" SO ID must NOT CONTAIN "-"
dh_organoid_ids <- as.list(c(unlist(list(ids))))

```

```{r, include = FALSE, message = FALSE}

# snakemake passes paths to input files as one string where paths to individual objects are separated by spaces. now we account for that here and get the separate paths.  
path_to_10X <- as.list(unlist(strsplit(params$path_to_10X[[1]], ' '))) 
dm_path <- as.list(unlist(strsplit(params$dm_path[[1]], ' '))) 

# make sce from 10x output and do qc
sce_raws <- sce_qcs <- list()
for(i in 1:length(dh_organoid_ids)){
  sce_raws[[i]] <- convert_to_sces(path_to_10X = path_to_10X[[i]], id = dh_organoid_ids[[i]])
  sce_qcs[[i]] <- make_sce_qc(whichMethod=params$whichMethod, sce=sce_raws[[i]], mito_thresh_max=params$mito_thresh_max, 
                              mito_thresh_min=params$mito_thresh_min, ribo_thresh_max=params$ribo_thresh_max, 
                              nmads=params$nmads, min_features=params$min_features, remove_mito_and_ribo=params$remove_mito_and_ribo)
}

# convert sce to seurat object
seurat_raws <- lapply(sce_raws, function(sce) CreateSeuratObject(counts = counts(sce), project = sce$id))
seurat_qc <- lapply(sce_qcs, function(sce) CreateSeuratObject(counts = counts(sce), project = sce$id))

# get colData from sce and store in dataframes
df_raws <- lapply(sce_raws, function(sce) colData(sce)) # this one has metrics before removing low quality cells
df_qcs <- lapply(sce_qcs, function(sce) colData(sce)) # this one has metrics after removing low quality cells

```

```{r include = FALSE}
# here we write a function to help us make dataframes that good for making plots later on 

makeTable <- function(df, index) {
  
  # first we must go from S4 to data frame to be able to use dplyr
  df <- as.data.frame(df) %>% 
    
    # get the mean for each column we are interested in 
    summarize(sum = as.integer(mean(sum)), 
              detected = as.integer(mean(detected)), 
              subsets_mito_sum = as.integer(mean(subsets_mito_sum)), 
              subsets_mito_percent = as.integer(mean(subsets_mito_percent)), 
              subsets_ribo_sum = as.integer(mean(subsets_ribo_sum)), 
              subsets_ribo_percent = as.integer(mean(subsets_ribo_percent))) %>% 

    mutate(id = dh_organoid_ids[[index]]) %>% 

    # add a new column with the number of cells 
    mutate(cell_number = nrow(df)) %>% 
    
    # here we take advantage of the select function to reorder the columns 
    dplyr::select(id, 
                  cell_number, 
                  sum, 
                  detected, 
                  subsets_mito_sum, 
                  subsets_mito_percent, 
                  subsets_ribo_sum, 
                  subsets_ribo_percent) %>% 
    
    # and here we just rename them for clarity 
    rename(RNA_reads = sum, 
           detected_genes = detected, 
           mito_reads = subsets_mito_sum, 
           mito_percent = subsets_mito_percent, 
           ribo_reads = subsets_ribo_sum, 
           ribo_percent = subsets_ribo_percent)
  
  return(df)
  
} # end of function 

makeTableMedian <- function(df, index) {
  
  # first we must go from S4 to data frame to be able to use dplyr
  df <- as.data.frame(df) %>% 
    
    mutate(RNA_reads = as.integer(median(sum)), 
           detected_genes = as.integer(median(detected)), 
           mito_reads = as.integer(median(subsets_mito_sum)), 
           mito_percent = as.integer(median(subsets_mito_percent)), 
           ribo_reads = as.integer(median(subsets_ribo_sum)), 
           ribo_percent = as.integer(median(subsets_ribo_percent))) %>% 
    
    summarize(RNA_reads = as.integer(mean(RNA_reads)), 
              detected_genes = as.integer(mean(detected_genes)), 
              mito_reads = as.integer(mean(mito_reads)), 
              mito_percent = as.integer(mean(mito_percent)), 
              ribo_reads = as.integer(mean(ribo_reads)), 
              ribo_percent = as.integer(mean(ribo_percent))) %>% 
    
    mutate(id = dh_organoid_ids[[index]]) %>% 
    
    dplyr::select(id, 
                  RNA_reads, 
                  detected_genes, 
                  mito_reads, 
                  mito_percent, 
                  ribo_reads, 
                  ribo_percent) 
                
  return(df)
  
} # end of function 


```

```{r echo = FALSE, warning = FALSE}

BEFORETable <- AFTERTable <- BEFORETable_median <- AFTERTable_median <- data.frame()

for(i in 1:length(df_raws)){
  # we gotta add some tables here before we jump into graphs. 
  # we first make a very very basic table, then make it look better. 

  before <- makeTable(df_raws[[i]], i)
  after <- makeTable(df_qcs[[i]], i)
  before_median <- makeTableMedian(df_raws[[i]], i)
  after_median <- makeTableMedian(df_qcs[[i]], i)

  # combine data from control and treatment in one table 
  BEFORETable <- rbind(BEFORETable, before)
  AFTERTable <- rbind(AFTERTable, after)
  BEFORETable_median <- rbind(BEFORETable_median, before_median)
  AFTERTable_median <- rbind(AFTERTable_median, after_median)

}


```


## Summary Statistics before and after quality control

```{r echo = FALSE, warning = FALSE, results = 'asis'}
# here we just make the tables look nice and add a caption as well. 
BEFORETable %>% 
  knitr::kable(caption = 'Table 1: Summary statistics showing cell number and MEAN values per cell- BEFORE quality control') %>% 
  kable_styling(full_width = F)
```

```{r echo = FALSE, warning = FALSE, results = 'asis'}
AFTERTable %>% 
  knitr::kable(caption = 'Table 2: Summary statistics showing cell number and MEAN values per cell- AFTER quality control') %>% 
  kable_styling(full_width = F)
```

```{r echo = FALSE, warning = FALSE, results = 'asis'}
BEFORETable_median %>% 
  knitr::kable(caption = 'Table 3: Summary statistics showing cell number and MEDIAN values per cell- BEFORE quality control') %>% 
  kable_styling(full_width = F)
```

```{r echo = FALSE, warning = FALSE, results = 'asis'}
AFTERTable_median %>% 
  knitr::kable(caption = 'Table 4: Summary statistics showing cell number and MEDIAN values per cell- AFTER quality control') %>% 
  kable_styling(full_width = F)
```


### Violin Plots

```{r include = FALSE}

all_raw <- seurat_raws[[1]]
all_qc <- seurat_qc[[1]]

# if there are more than 1 sample, combine them into one seurat object
if(length(seurat_raws) > 1){
  for(i in 2:length(seurat_raws)){
    all_raw <- merge(all_raw, seurat_raws[[i]], add.cell.ids = c(dh_organoid_ids[[i-1]], dh_organoid_ids[[i]]))
    all_qc <- merge(all_qc, seurat_qc[[i]], add.cell.ids = c(dh_organoid_ids[[i-1]], dh_organoid_ids[[i]]))
  }
}

if(grepl("^ENSMUS", sce_raws[[1]]@rowRanges@elementMetadata@listData[["ID"]][1]) ){
  # for mouse
  all_raw[["percent_mito"]] <- PercentageFeatureSet(all_raw, pattern = "^mt-")
  all_qc[["percent_mito"]] <- PercentageFeatureSet(all_qc, pattern = "^mt-")

  all_raw[["percent_ribo"]] <- PercentageFeatureSet(all_raw, pattern = "^Rp[sl][[:digit:]]")
  all_qc[["percent_ribo"]] <- PercentageFeatureSet(all_qc, pattern = "^Rp[sl][[:digit:]]")
} else {
  # for human
  all_raw[["percent_mito"]] <- PercentageFeatureSet(all_raw, pattern = "^MT-")
  all_qc[["percent_mito"]] <- PercentageFeatureSet(all_qc, pattern = "^MT-")

  all_raw[["percent_ribo"]] <- PercentageFeatureSet(all_raw, pattern = "^RP[LS]")
  all_qc[["percent_ribo"]] <- PercentageFeatureSet(all_qc, pattern = "^RP[LS]")
}

feats <- c("nFeature_RNA","nCount_RNA","percent_mito","percent_ribo")

```

#### BEFORE quality control
```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 13}

VlnPlot(all_raw, group.by= "orig.ident", features = feats, pt.size = 0.1,ncol = 4) 

```


#### AFTER quality control
```{r echo = FALSE, message = FALSE,  warning = FALSE, fig.height = 5, fig.width = 13}

VlnPlot(all_qc, group.by= "orig.ident", features = feats, pt.size = 0.1,ncol = 4)

```


### Scatter Plots and Pearson Correlation between Features

We can also look into the relationship between certain values in scatter plots. Pearson correlation between the two features is displayed above the plot. 

#### BEFORE QUALITY CONTROL 

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 17}

cowplot::plot_grid(ncol = 4,
  FeatureScatter(all_raw, "nCount_RNA"  , "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_raw, "percent_mito", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_raw, "percent_ribo", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_raw, "percent_ribo", "percent_mito", group.by = "orig.ident", pt.size = .5)
)

```

#### AFTER QUALITY CONTROL 

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 17}

cowplot::plot_grid(ncol = 4,
  FeatureScatter(all_qc, "nCount_RNA"  , "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_qc, "percent_mito", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_qc, "percent_ribo", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_qc, "percent_ribo", "percent_mito", group.by = "orig.ident", pt.size = .5)
)

```


## Dimensionality Reduction Plots

Next we include some dimensionality reduction plots (PCA, tSNE, and UMAP). Plots on the left are before quality control, plots on the right are after. 

```{r echo = FALSE, message = FALSE, warning = FALSE}

dim_red_plot <- function(seurat_obj){
  p <- list()
  
  # scale data before PCA
  seurat_obj <- FindVariableFeatures(seurat_obj)
  seurat_obj <- ScaleData(seurat_obj)

  # run PCA, UMAP, and TSNE
  seurat_obj <- RunPCA(seurat_obj, verbose = FALSE)
  seurat_obj <- RunUMAP(seurat_obj, dims = 1:30)
  seurat_obj <- RunTSNE(seurat_obj, dims = 1:30, check_duplicates = FALSE, perplexity = 10)
  
  # Get the total variance and compute variance explained by the first 2 PCs
  total_variance <- seurat_obj[["pca"]]@misc$total.variance
  eigValues <- (seurat_obj[["pca"]]@stdev)^2 
  varExplained <- label_percent()(eigValues/total_variance)[1:2] 
  
  # dim reduction plot
  p[[1]] <- DimPlot(seurat_obj, reduction = 'pca', group.by = 'orig.ident') + xlab(paste0("PC1: ", varExplained[1])) + ylab(paste0("PC2: ", varExplained[2]))
  p[[2]] <- DimPlot(seurat_obj, reduction = 'tsne', group.by = 'orig.ident', combine = FALSE)
  p[[3]] <- DimPlot(seurat_obj, reduction = 'umap', group.by = 'orig.ident', combine = FALSE)
  
  return(p)
}

before <- dim_red_plot(all_raw)
after <- dim_red_plot(all_qc)

```

```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 15}

grid.arrange(ggplotify::as.grob(before[[1]]), ggplotify::as.grob(after[[1]]), nrow = 1)

```

```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 15}

grid.arrange(ggplotify::as.grob(before[[2]][[1]]), ggplotify::as.grob(after[[2]][[1]]), nrow = 1)

```

```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 15}

grid.arrange(ggplotify::as.grob(before[[3]][[1]]), ggplotify::as.grob(after[[3]][[1]]), nrow = 1)

```



## Most variable features

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. Here we find the 3000 most variable features (genes) in two datasets **after** quality control. Datatables below have include these genes, but we label the top 15 genes for both datasets. 

```{r include = FALSE}

most_variable_features <- function(seurat_obj, id){
  
  seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = "vst", nfeatures = 3000)

  # Identify the 15 most highly variable genes
  top10 <- head(VariableFeatures(seurat_obj), 15)

  # plot variable features with labels
  p <- LabelPoints(plot = VariableFeaturePlot(seurat_obj), points = top10, repel = TRUE) + 
    ggtitle(id) + theme(legend.position = "bottom")
  
  out <- list(seurat_obj=seurat_obj, plot=p)
}

```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 5}

mvf <- list()
for(i in 1:length(seurat_qc)){
  mvf[[i]] <- most_variable_features(seurat_qc[[i]], dh_organoid_ids[[i]])
  print(mvf[[i]]$plot)
}

```


#### Most variable genes 

```{r}

t <- htmltools::tagList()
for(i in 1:length(mvf)){
  t[[i]] <- print(DT::datatable(HVFInfo(mvf[[i]]$seurat_obj)[VariableFeatures(mvf[[i]]$seurat_obj), ],
                                extensions = 'Buttons',
                                options = list(dom = 'Bfrtip', buttons = list("copy", "excel", "csv", "pdf")),
                                caption = paste0("Most variable genes in ", dh_organoid_ids[[i]])))
}
t

```


#### Number of highly variable genes (HVG)

Number of HVG for both samples are given below for various gene dispersion (variance) cut offs.  

```{r include = FALSE}

process_seurat <- function(seurat_obj){
  
  # normalize count and find variable features
  normalized <- NormalizeData(seurat_obj) %>% 
    FindVariableFeatures(selection.method = 'dispersion', mean.cutoff = c(0.005, 1))
  
  # scale and run clustering
  clustered <- ScaleData(normalized) %>% 
    RunPCA(verbose = FALSE) %>% 
    RunUMAP(dims = 1:30, n.components=3) %>% 
    RunTSNE(dims = 1:30, dim.embed = 3, check_duplicates = FALSE) %>% 
    FindNeighbors(dims = 1:10) %>% 
    FindClusters(resolution = 0.5)
  
  # store normalized and clustered object in a list 
  out <- list(normalized = normalized, clustered = clustered)
  
  return(out)
}


getNumberOfHVG <- function(object, threshold){
  
  #### Number of variable features  
  # Here we find the number of variable features with various cutoffs after quality control. 
  num_hvg <- numeric()
  
  for(i in 1:length(threshold)){
    num_hvg[i] <- as.data.frame(HVFInfo(object = object)) %>% 
      dplyr::select(dispersion.scaled) %>% 
      dplyr::filter(dispersion.scaled > threshold[i]) %>% 
      nrow()
  }
  
  return(num_hvg)
}

```


```{r include=FALSE}

pro_sample <- qc_sample <- HVG_sample <- list()
dispersion_cutoff <- c(0.5, 1.0, 1.5, 2.0, 2.5)
df <- data.frame(dispersion_cutoff)

for(i in 1:length(seurat_qc)){
  pro_sample[[i]] <- process_seurat(seurat_qc[[i]])
  qc_sample[[i]] <- pro_sample[[i]]$normalized
  HVG_sample[[i]] <- getNumberOfHVG(qc_sample[[i]], dispersion_cutoff)
  df <- data.frame(df, HVG_sample[[i]])
  names(df)[i+1] <- paste('HVG', dh_organoid_ids[[i]], sep = '_')
}

```

```{r}

df %>% 
  knitr::kable(caption = 'Table 5: Number of HVG after quality control') %>% 
  kable_styling(full_width = F)

```


## Clustering

Clustering cells and running a DE analysis between clusters can give an idea about different cell populations that may exist in the samples and various gene expression patterns. To better understand the composition of the clusters, we will look into these factors and show them on plots:  

* mitochondrial content (percentage)  
* ribosomal content (percentage)  
* number of detected genes  

0.5 was chosen as a resolution. Larger resolution gives you more clusters. The recommended resoluation range is 0.4-1.2 for dataset with ~3k cells.

Now let's look at the chosen resolution (0.5) in more detail. We visualize the clusters in a dimensionality reduction plots below. 

#### PCA
```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10}

for(i in 1:length(pro_sample)){
  qc_sample[[i]] <- pro_sample[[i]]$clustered
  
  # Get the total variance and compute variance explained by the first 2 PCs
  total_variance <- qc_sample[[i]][["pca"]]@misc$total.variance
  eigValues <- (qc_sample[[i]][["pca"]]@stdev)^2 
  varExplained <- label_percent()(eigValues/total_variance)[1:2] 
  
  print(DimPlot(qc_sample[[i]], reduction = "pca") + ggtitle(dh_organoid_ids[[i]]) +
     xlab(paste0("PC1: ", varExplained[1])) + ylab(paste0("PC2: ", varExplained[2]))) 
}


```


#### t-SNE
```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10}

for(i in 1:length(pro_sample)){
  print(DimPlot(qc_sample[[i]], reduction = "tsne") + ggtitle(dh_organoid_ids[[i]]))
}


```

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10, eval=FALSE}

# if we want to change colors:

colors_list <- c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F", "#E5C494", "#B3B3B3", '#E2201C', '#1D91C0', '#6B3E9A', '#32A028', "deepskyblue", "black")

min_cluster <- as.numeric(min(as.vector(pro_sample[[1]]$cluster$seurat_clusters)))
max_cluster <- as.numeric(max(as.vector(pro_sample[[1]]$cluster$seurat_clusters)))

cluster_name <- min_cluster:max_cluster
colors_list <- colors_list[1:(max_cluster+1)]


for(i in 1:length(pro_sample)){
  qc_sample[[i]] <- pro_sample[[i]]$clustered
  print(DimPlot(qc_sample[[i]], reduction = "tsne") + 
          ggtitle(dh_organoid_ids[[i]]) + 
          scale_color_manual(values=colors_list))
}

```


#### UMAP
```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10}

for(i in 1:length(pro_sample)){
  print(DimPlot(qc_sample[[i]], reduction = "umap") + ggtitle(dh_organoid_ids[[i]]))
}

```

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10, eval=FALSE}

for(i in 1:length(pro_sample)){
  print(DimPlot(qc_sample[[i]], reduction = "umap") + 
          ggtitle(dh_organoid_ids[[i]]) +
          scale_color_manual(values=colors_list))
}

```

#### Diffusion map

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10}

# remove grid from plot_ly
ax <- list(zeroline = FALSE, showline = TRUE, showgrid = FALSE)

PlotDiffMap <- function(dat, dm_path, dim){

  logcounts <- GetAssayData(dat) %>% as.matrix  
  
  # compute diffusion map
  if(!file.exists(dm_path)){
    dm <- DiffusionMap(t(logcounts), n_pcs = 30)
    if(!dir.exists(dm_path)) dir.create(dirname(dm_path)) # create sample folder
    saveRDS(dm, file=dm_path)
  } else{
    dm <- readRDS(dm_path)
  }
  
  # make df with the diffusion map coodinates, we will use this later to make the dm plot 
  tmp <- data.frame(DC1 = eigenvectors(dm)[, 1],
                  DC2 = eigenvectors(dm)[, 2],
                  DC3 = eigenvectors(dm)[, 3],
                  Timepoint = as.factor(dat$seurat_clusters), 
                  ids = dat$orig.ident) # this will help color based on cluster 

  # remove grid from plot_ly
  ax <- list(zeroline = FALSE, showline = TRUE, showgrid = FALSE)

  if(dim==2){
    # make the 2D plot 
    p <- plot_ly(data = tmp,
        x = ~DC1, y = ~DC2,
        opacity = 1,
        color = ~Timepoint,
        type = "scatter",
        mode = "markers",
        marker = list(size = 5)) %>% 
      layout(legend= list(itemsizing='constant'), title=dh_organoid_ids[[i]])
  } else {
    # make the 3d plot 
   p <- plot_ly(data = tmp,
        x = ~DC1, y = ~DC2, z = ~DC3,
        opacity = 1,
        color = ~Timepoint,
        type = "scatter3d",
        mode = "markers",
        marker = list(size = 3))  %>% 
      layout(legend= list(itemsizing='constant'), title=dh_organoid_ids[[i]])
  }
  return(p)
}

l2 <- l3 <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- PlotDiffMap(qc_sample[[i]], dm_path[[i]], dim=2)
  l3[[i]] <- PlotDiffMap(qc_sample[[i]], dm_path[[i]], dim=3)
}

l2
l3
```


#### 2d UMAP and tSNE showing logcounts of reporter genes (if there is any)

```{r}
# add genes of interest here:
reporters <- strsplit(as.character(params$reporter_genes), " ")[[1]] 

PlotReporter <- function(reporters, sce){
  p <- htmltools::tagList()
  for(i in 1:length(reporters)){
  if(any(grepl(paste("^",reporters[i],"$", sep=""), rownames(sce), ignore.case = TRUE) == TRUE)){
    
    # if our sample contains one of the reporter genes:
    count <- GetAssayData(sce) %>% as.matrix  
    reporter_idx <- grep(paste("^",reporters[i],"$", sep=""), rownames(sce), ignore.case = TRUE)
    count_reporter <- count[reporter_idx,]
    
    df_umap <- cbind(sce[["umap"]]@cell.embeddings %>% as.data.frame(), sce[["tsne"]]@cell.embeddings %>% as.data.frame())
    df_umap$logcounts <- count_reporter
    
  p2 <- plot_ly(data = df_umap,
        x = ~UMAP_1, y = ~UMAP_2,
        opacity = 1,
        color = ~logcounts,
        type = "scatter",
        mode = "markers",
        marker = list(size = 4), 
        colors = brewer.pal(6, "Reds")) %>% 
          layout(legend= list(itemsizing='constant'), xaxis = ax, yaxis = ax, showlegend=F)
  
    p3 <- plot_ly(data = df_umap,
        x = ~tSNE_1, y = ~tSNE_2,
        opacity = 1,
        color = ~logcounts,
        type = "scatter",
        mode = "markers",
        marker = list(size = 4), 
        colors = brewer.pal(6, "Reds")) %>% 
          layout(title=paste0(sce$orig.ident %>% unique(), ": ", reporters[[i]], "_logcount"),
         legend= list(itemsizing='constant'), xaxis = ax, yaxis = ax, showlegend=F)
    
    p[[i]] <- subplot(p2, p3, titleX=T, titleY=T)
  }
  }
  return(p)
}

p <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  p[[i]] <- PlotReporter(reporters, qc_sample[[i]])
}
p

```

### Number of cells in each cluster

```{r}

MakeTableClusters <- function(dat){
  # make a table summarizing number of cells per cluster
  clus <- dat$seurat_clusters %>% levels() 
  df <- matrix(NA, ncol=2, nrow=length(clus))
  for(i in 1:length(clus)){
    num_cell <- which(dat$seurat_clusters==clus[i]) %>% length()
    df[i,] <- c(clus[i], num_cell)
}

  # convert matrix to dataframe and add column name
  df <- data.frame(df)
  colnames(df) <- c("Cluster", "Number of Cells")
  
  return(df)
}

df <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  df[[i]] <- MakeTableClusters(qc_sample[[i]]) %>% 
    datatable(caption = paste0('Number of cells per cluster in ', dh_organoid_ids[[i]]))
}
df

```


## Visualize Clusters with Violin Plots

Now, we will look into the contents of these clusters and visualize these values in the violin plots below.  

```{r include = FALSE}

clus_violin <- function(sce, clus_seurat){
  
  # now lets compute the statistics above in plots, for that we need to add the clusters information to the sce objects 
  sample_info_df <- data.frame(clusters=clus_seurat$seurat_clusters, mito_percentage=sce$subsets_mito_percent, 
                               ribo_percentage=sce$subsets_ribo_percent, detected_genes=sce$detected)
  
  # now we make the plots 
  plot_sample_mito <- ggplot(sample_info_df, aes(x = factor(clusters), y = mito_percentage, fill = factor(clusters))) + 
    geom_violin() + 
    geom_jitter(height = 0.1, width = 0.08) + 
    theme_classic() + 
    ggtitle('mitochondrial content')

  plot_sample_ribo <- ggplot(sample_info_df, aes(x = factor(clusters), y = ribo_percentage, fill = factor(clusters))) + 
    geom_violin() + 
    geom_jitter(height = 0.1, width = 0.08) + 
    theme_classic() + 
    ggtitle('ribosomal content') + ylim(0, 40)

  plot_sample_genes <- ggplot(sample_info_df, aes(x = factor(clusters), y = detected_genes, fill = factor(clusters))) + 
    geom_violin() + 
    geom_jitter(height = 0.1, width = 0.08) + 
    theme_classic() + 
    ggtitle('detected genes') + ylim(0, 10000)
  
  p <- list(plot_sample_mito = plot_sample_mito, plot_sample_ribo = plot_sample_ribo, plot_sample_genes = plot_sample_genes)
  
  return(p)
}


```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 18}

sample <- list()

for(i in 1:length(pro_sample)){
  sample[[i]] <- clus_violin(sce_qcs[[i]], pro_sample[[i]]$clustered)
  print(grid.arrange(sample[[i]]$plot_sample_mito, sample[[i]]$plot_sample_ribo, sample[[i]]$plot_sample_genes, nrow = 1,
                     top = dh_organoid_ids[[i]]))
}

```



## Dimension Reduction showing Number of Detected Reads

We can also visualize number of detected reads on a log-scale with dimension reduction plots. 

```{r include=FALSE}

dim_red_df <- function(sample){
  
  # get pca coordinates 
  pca_1 <- as.numeric(Embeddings(object = sample$clustered, reduction = "pca")[,1])
  pca_2 <- as.numeric(Embeddings(object = sample$clustered, reduction = "pca")[,2])
  pca_3 <- as.numeric(Embeddings(object = sample$clustered, reduction = "pca")[,3])

  # get tsne coordinates 
  tsne_1 <- as.numeric(Embeddings(object = sample$clustered, reduction = "tsne")[,1])
  tsne_2 <- as.numeric(Embeddings(object = sample$clustered, reduction = "tsne")[,2])
  tsne_3 <- as.numeric(Embeddings(object = sample$clustered, reduction = "tsne")[,3])

  # get umap coordinates 
  umap_1 <- as.numeric(Embeddings(object = sample$clustered, reduction = "umap")[,1])
  umap_2 <- as.numeric(Embeddings(object = sample$clustered, reduction = "umap")[,2])
  umap_3 <- as.numeric(Embeddings(object = sample$clustered, reduction = "umap")[,3])

  # add information on number of detected reads on a log scale
  umi_df <- GetAssayData(object = sample$clustered, slot = "counts") %>% colSums() %>% log()

  # make dfs 
  df_tsne <- data.frame(tsne_1, tsne_2, tsne_3)
  df_tsne$cluster <- as.factor(sample$clustered$seurat_clusters)
  df_tsne$reads <- umi_df

  df_pca <- data.frame(pca_1, pca_2, pca_3)
  df_pca$cluster <- as.factor(sample$clustered$seurat_clusters)
  df_pca$reads <- umi_df

  df_umap <- data.frame(umap_1, umap_2, umap_3)
  df_umap$cluster <- as.factor(sample$clustered$seurat_clusters)
  df_umap$reads <- umi_df
  
  df_all <- list(df_pca, df_tsne, df_umap)
  
  return(df_all)
}

dimred_df <- list()
for(i in 1:length(pro_sample)){
  dimred_df[[i]] <- dim_red_df(pro_sample[[i]])
}

```



```{r include=FALSE}

reads_plot <- function(df, dim){
  if(dim==2){
    p <- plot_ly(data = df,
        x = ~df[,1], y = ~df[,2],
        opacity = 1,
        color = ~reads,
        type = "scatter",
        mode = "markers",
        marker = list(size = 3), 
        hovertext = paste("log(Reads):", df$reads)) %>% 
  layout(legend= list(itemsizing='constant'), title=dh_organoid_ids[[i]])
  } else {
    p <- plot_ly(data = df,
        x = ~df[,1], y = ~df[,2], z = ~df[,3],
        opacity = 1,
        color = ~reads,
        type = "scatter3d",
        mode = "markers",
        marker = list(size = 3), 
        hovertext = paste("log(Reads):", df$reads)) %>% 
  layout(legend= list(itemsizing='constant', title=dh_organoid_ids[[i]]))
  }
  return(p)
}


```


#### PCA
```{r fig.height = 5, fig.width = 10}

l2 <- l3 <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- reads_plot(df=dimred_df[[i]][[1]], dim=2)
  l3[[i]] <- reads_plot(df=dimred_df[[i]][[1]], dim=3)
}

l2
l3
```

#### t-SNE
```{r fig.height = 5, fig.width = 10}

l2 <- l3 <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- reads_plot(df=dimred_df[[i]][[2]], dim=2)
  l3[[i]] <- reads_plot(df=dimred_df[[i]][[2]], dim=3)
}

l2
l3
```

#### UMAP
```{r fig.height = 5, fig.width = 10}

l2 <- l3 <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- reads_plot(df=dimred_df[[i]][[3]], dim=2)
  l3[[i]] <- reads_plot(df=dimred_df[[i]][[3]], dim=3)
}

l2
l3
```

## Finding differentially expressed features

A heatmap of gene expression of gene markers for each cluster. Data used for plotting are centered and scaled. Yellow and purple mean high and low expression, respectively. We also include a table showing top 10 upregulated genes in each cluster. 

```{r fig.height = 15, fig.width = 16, message=FALSE, echo = FALSE, warning=FALSE}

hm <- d <- htmltools::tagList()
for(i in 1:length(pro_sample)){
  # find markers for every cluster compared to all remaining cells, report only the positive ones
  dat.markers <- FindAllMarkers(qc_sample[[i]], only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
  
  # get top 10 DEGs and plot heatmap
  top10 <- dat.markers %>%
    group_by(cluster) %>%
    top_n(n = 10, wt = avg_logFC)
  
  print(DoHeatmap(qc_sample[[i]], features = top10$gene) + NoLegend() + labs(title = dh_organoid_ids[[i]]))
  
  # make a table to show top10 upregulated genes in each cluster
  min.clus <- as.numeric(min(as.vector(qc_sample[[i]]$seurat_clusters)))
  max.clus <- as.numeric(max(as.vector(qc_sample[[i]]$seurat_clusters)))

  ind <- min.clus:max.clus
  df <- matrix(NA, nrow=10, ncol=length(ind))
  for(j in 1:length(ind)){
    temp <- top10 %>% filter(cluster==ind[j])
    df[,j] <- temp$gene
}

  df <- data.frame(df, stringsAsFactors = FALSE)
  colnames(df) <- paste("cluster", ind, "markers", sep=" ")

  d[[i]] <- df %>% datatable(caption = paste0('Top10 upregulated genes in each cluster in ', dh_organoid_ids[[i]]))
}

d


```










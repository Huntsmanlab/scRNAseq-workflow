---
title: " `r params$ids` Summary stats and quality control results"
subtitle: '`r params$pair_ids`'
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 4
    toc_float: true

params:
  pair_ids: 'YW1-DH21' # to run this, write TWO ids here, separated by -
  whichMethod: 'default' # to use different parameters here, just update them.
  min_features: 1000
  mito_thresh_max: 60
  mito_thresh_min: 1
  ribo_thresh_max: 60 
  nmads: 3
  remove_mito_and_ribo: "yes" # "yes" will remove all mito and ribo genes, "no" will retain them both in the sce

---

In this document, we show summary statistics and results of quality control on the samples. The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features.  

While filtering low quality cells, we consider the following:  

* Total number of RNA reads detected in each cell  
* The number of unique genes detected in each cell:  
  + Low-quality cells or empty droplets will often have very few genes while cell doublets or multiplets may exhibit an aberrantly high gene count.  
* The percentage of reads that map to the mitochondrial genome:  
  + Low-quality / dying cells often exhibit extensive mitochondrial contamination. We restrict the mitochondrial content to 25% of all the reads.  
* The percentage of reads that map to ribosomal RNA:  
  + Ribosomal content is restricted to 60% per cell.  


```{css, echo=FALSE}
    body .main-container {
      max-width: 90% !important;
      width: 90% !important;
    }

    body {
      max-width: 90% !important;
    }
```

```{r include = FALSE}
# source the files for the functions we need 
library(here)
source(here('pipeline', 'sourceFiles', 'utilities.R'))
source(here('pipeline', 'process_qc_normalization', 'data_preparation', 'convert_to_sces.R'))
source(here('pipeline', 'process_qc_normalization', 'qc', 'default_qc.R'))

```

```{r include = FALSE}

#extract the name_list from the parameters. we use the name list later on while making graphs. 
ids <- strsplit(params$pair_ids, "[-/ ]")[[1]] # split by "-" SO ID must NOT CONTAIN "-"
dh_organoid_ids <- as.list(c(unlist(list(ids))))
path_to_10X <- lapply(dh_organoid_ids, function(id) here('..', 'huntsmandata', 'raw', id))

# make sce from 10x output and do qc
sce_raws <- sce_qcs <- list()
for(i in 1:length(dh_organoid_ids)){
  sce_raws[[i]] <- convert_to_sces(path_to_10X = path_to_10X[[i]], id = dh_organoid_ids[[i]])
  sce_qcs[[i]] <- make_sce_qc(params$whichMethod, sce_raws[[i]], params$mito_thresh_max, params$mito_thresh_min, params$ribo_thresh_max, 
                              params$nmads, params$min_features, params$remove_mito_and_ribo)
}

# convert sce to seurat object
seurat_raws <- lapply(sce_raws, function(sce) CreateSeuratObject(counts = counts(sce), project = sce$id))
seurat_qc <- lapply(sce_qcs, function(sce) CreateSeuratObject(counts = counts(sce), project = sce$id))

# get colData from sce and store in dataframes
df_raws <- lapply(sce_raws, function(sce) colData(sce)) # this one has metrics before removing low quality cells 
df_qcs <- lapply(sce_qcs, function(sce) colData(sce)) # this one has metrics after removing low quality cells 

```

```{r include = FALSE}
# here we write a function to help us make dataframes that good for making plots later on 

makeTable <- function(df, index) {
  
  # first we must go from S4 to data frame to be able to use dplyr
  df <- as.data.frame(df) %>% 
    
    # get the mean for each column we are interested in 
    summarize(sum = as.integer(mean(sum)), 
              detected = as.integer(mean(detected)), 
              subsets_mito_sum = as.integer(mean(subsets_mito_sum)), 
              subsets_mito_percent = as.integer(mean(subsets_mito_percent)), 
              subsets_ribo_sum = as.integer(mean(subsets_ribo_sum)), 
              subsets_ribo_percent = as.integer(mean(subsets_ribo_percent))) %>% 

    mutate(id = dh_organoid_ids[[index]]) %>% 

    # add a new column with the number of cells 
    mutate(cell_number = nrow(df)) %>% 
    
    # here we take advantage of the select function to reorder the columns 
    dplyr::select(id, 
                  cell_number, 
                  sum, 
                  detected, 
                  subsets_mito_sum, 
                  subsets_mito_percent, 
                  subsets_ribo_sum, 
                  subsets_ribo_percent) %>% 
    
    # and here we just rename them for clarity 
    rename(RNA_reads = sum, 
           detected_genes = detected, 
           mito_reads = subsets_mito_sum, 
           mito_percent = subsets_mito_percent, 
           ribo_reads = subsets_ribo_sum, 
           ribo_percent = subsets_ribo_percent)
  
  return(df)
  
} # end of function 

makeTableMedian <- function(df, index) {
  
  # first we must go from S4 to data frame to be able to use dplyr
  df <- as.data.frame(df) %>% 
    
    mutate(RNA_reads = as.integer(median(sum)), 
           detected_genes = as.integer(median(detected)), 
           mito_reads = as.integer(median(subsets_mito_sum)), 
           mito_percent = as.integer(median(subsets_mito_percent)), 
           ribo_reads = as.integer(median(subsets_ribo_sum)), 
           ribo_percent = as.integer(median(subsets_ribo_percent))) %>% 
    
    summarize(RNA_reads = as.integer(mean(RNA_reads)), 
              detected_genes = as.integer(mean(detected_genes)), 
              mito_reads = as.integer(mean(mito_reads)), 
              mito_percent = as.integer(mean(mito_percent)), 
              ribo_reads = as.integer(mean(ribo_reads)), 
              ribo_percent = as.integer(mean(ribo_percent))) %>% 
    
    mutate(id = dh_organoid_ids[[index]]) %>% 
    
    dplyr::select(id, 
                  RNA_reads, 
                  detected_genes, 
                  mito_reads, 
                  mito_percent, 
                  ribo_reads, 
                  ribo_percent) 
                
  return(df)
  
} # end of function 


```

```{r echo = FALSE, warning = FALSE}

BEFORETable <- AFTERTable <- BEFORETable_median <- AFTERTable_median <- data.frame()

for(i in 1:length(df_raws)){
  # we gotta add some tables here before we jump into graphs. 
  # we first make a very very basic table, then make it look better. 

  before <- makeTable(df_raws[[i]], i)
  after <- makeTable(df_qcs[[i]], i)
  before_median <- makeTableMedian(df_raws[[i]], i)
  after_median <- makeTableMedian(df_qcs[[i]], i)

  # combine data from control and treatment in one table 
  BEFORETable <- rbind(BEFORETable, before)
  AFTERTable <- rbind(AFTERTable, after)
  BEFORETable_median <- rbind(BEFORETable_median, before_median)
  AFTERTable_median <- rbind(AFTERTable_median, after_median)

}


```


## Summary Statistics before and after quality control

```{r echo = FALSE, warning = FALSE, results = 'asis'}
# here we just make the tables look nice and add a caption as well. 
BEFORETable %>% 
  knitr::kable(caption = 'Table 1: Summary statistics showing cell number and MEAN values per cell- BEFORE quality control') %>% 
  kable_styling(full_width = F)
```

```{r echo = FALSE, warning = FALSE, results = 'asis'}
AFTERTable %>% 
  knitr::kable(caption = 'Table 2: Summary statistics showing cell number and MEAN values per cell- AFTER quality control') %>% 
  kable_styling(full_width = F)
```

```{r echo = FALSE, warning = FALSE, results = 'asis'}
BEFORETable_median %>% 
  knitr::kable(caption = 'Table 3: Summary statistics showing cell number and MEDIAN values per cell- BEFORE quality control') %>% 
  kable_styling(full_width = F)
```

```{r echo = FALSE, warning = FALSE, results = 'asis'}
AFTERTable_median %>% 
  knitr::kable(caption = 'Table 4: Summary statistics showing cell number and MEDIAN values per cell- AFTER quality control') %>% 
  kable_styling(full_width = F)
```



### Violin Plots

```{r include = FALSE}

all_raw <- seurat_raws[[1]]
all_qc <- seurat_qc[[1]]

# if there are more than 1 sample, combine them into one seurat object
if(length(seurat_raws) > 1){
  for(i in 2:length(seurat_raws)){
    all_raw <- merge(all_raw, seurat_raws[[i]], add.cell.ids = c(dh_organoid_ids[[i-1]], dh_organoid_ids[[i]]))
    all_qc <- merge(all_qc, seurat_qc[[i]], add.cell.ids = c(dh_organoid_ids[[i-1]], dh_organoid_ids[[i]]))
  }
}

if(grepl("^ENSMUS", sce_raws[[1]]@rowRanges@elementMetadata@listData[["ID"]][1]) ){
  # for mouse
  all_raw[["percent_mito"]] <- PercentageFeatureSet(all_raw, pattern = "^mt-")
  all_qc[["percent_mito"]] <- PercentageFeatureSet(all_qc, pattern = "^mt-")

  all_raw[["percent_ribo"]] <- PercentageFeatureSet(all_raw, pattern = "^Rp[sl][[:digit:]]")
  all_qc[["percent_ribo"]] <- PercentageFeatureSet(all_qc, pattern = "^Rp[sl][[:digit:]]")
} else {
  # for human
  all_raw[["percent_mito"]] <- PercentageFeatureSet(all_raw, pattern = "^MT-")
  all_qc[["percent_mito"]] <- PercentageFeatureSet(all_qc, pattern = "^MT-")

  all_raw[["percent_ribo"]] <- PercentageFeatureSet(all_raw, pattern = "^RP[LS]")
  all_qc[["percent_ribo"]] <- PercentageFeatureSet(all_qc, pattern = "^RP[LS]")
}

feats <- c("nFeature_RNA","nCount_RNA","percent_mito","percent_ribo")

```

#### BEFORE quality control
```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 13}

VlnPlot(all_raw, group.by= "orig.ident", features = feats, pt.size = 0.1,ncol = 4) 

```


#### AFTER quality control
```{r echo = FALSE, message = FALSE,  warning = FALSE, fig.height = 5, fig.width = 13}

VlnPlot(all_qc, group.by= "orig.ident", features = feats, pt.size = 0.1,ncol = 4)

```


### Scatter Plots and Pearson Correlation between Features

We can also look into the relationship between certain values in scatter plots. Pearson correlation between the two features is displayed above the plot. 

#### BEFORE QUALITY CONTROL 

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 17}

cowplot::plot_grid(ncol = 4,
  FeatureScatter(all_raw, "nCount_RNA"  , "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_raw, "percent_mito", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_raw, "percent_ribo", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_raw, "percent_ribo", "percent_mito", group.by = "orig.ident", pt.size = .5)
)

```

#### AFTER QUALITY CONTROL 

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 17}

cowplot::plot_grid(ncol = 4,
  FeatureScatter(all_qc, "nCount_RNA"  , "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_qc, "percent_mito", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_qc, "percent_ribo", "nFeature_RNA", group.by = "orig.ident", pt.size = .5),
  FeatureScatter(all_qc, "percent_ribo", "percent_mito", group.by = "orig.ident", pt.size = .5)
)

```


## Dimensionality Reduction Plots

Next we include some dimensionality reduction plots (PCA, tSNE, and UMAP). Plots on the left are before quality control, plots on the right are after. 

```{r echo = FALSE, message = FALSE, warning = FALSE}

dim_red_plot <- function(seurat_obj){
  p <- list()
  
  seurat_obj <- FindVariableFeatures(seurat_obj)
  seurat_obj <- ScaleData(seurat_obj)

  seurat_obj <- RunPCA(seurat_obj, verbose = FALSE)
  seurat_obj <- RunUMAP(seurat_obj, dims = 1:30)
  seurat_obj <- RunTSNE(seurat_obj, dims = 1:30, check_duplicates = FALSE, perplexity = 10)

  p[[1]] <- DimPlot(seurat_obj, reduction = 'pca', group.by = 'orig.ident', combine = FALSE)
  p[[2]] <- DimPlot(seurat_obj, reduction = 'tsne', group.by = 'orig.ident', combine = FALSE)
  p[[3]] <- DimPlot(seurat_obj, reduction = 'umap', group.by = 'orig.ident', combine = FALSE)
  
  return(p)
}

before <- dim_red_plot(all_raw)
after <- dim_red_plot(all_qc)

```

```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 15}

grid.arrange(ggplotify::as.grob(before[[1]][[1]]), ggplotify::as.grob(after[[1]][[1]]), nrow = 1)

```

```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 15}

grid.arrange(ggplotify::as.grob(before[[2]][[1]]), ggplotify::as.grob(after[[2]][[1]]), nrow = 1)

```

```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 15}

grid.arrange(ggplotify::as.grob(before[[3]][[1]]), ggplotify::as.grob(after[[3]][[1]]), nrow = 1)

```


## Most variable features

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. Here we find the 3000 most variable features (genes) in two datasets **after** quality control. Datatables below have include these genes, but we label the top 15 genes for both datasets. 

```{r include = FALSE}

most_variable_features <- function(seurat_obj, id){
  
  seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = "vst", nfeatures = 3000)

  # Identify the 15 most highly variable genes
  top10 <- head(VariableFeatures(seurat_obj), 15)

  # plot variable features with labels
  p <- LabelPoints(plot = VariableFeaturePlot(seurat_obj), points = top10, repel = TRUE) + 
    ggtitle(id) + theme(legend.position = "bottom")
  
  out <- list(seurat_obj=seurat_obj, plot=p)
}

```

```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 5}

mvf <- list()
for(i in 1:length(seurat_qc)){
  mvf[[i]] <- most_variable_features(seurat_qc[[i]], dh_organoid_ids[[i]])
  print(mvf[[i]]$plot)
}

```


#### Most variable genes  
```{r}

for(i in 1:length(mvf)){
  print(DT::datatable(HVFInfo(mvf[[i]]$seurat_obj)[VariableFeatures(mvf[[i]]$seurat_obj), ],
  extensions = 'Buttons',
  options = list(dom = 'Bfrtip',
                 buttons = list("copy", "excel", "csv", "pdf")),
  caption = paste0("Most variable genes in ", dh_organoid_ids[[i]])))
}

```



#### Number of highly variable genes (HVG)

Number of HVG for both samples are given below for various gene dispersion (variance) cut offs.  

```{r include = FALSE}

process_seurat <- function(seurat_obj){
  
  # normalize count and find variable features
  normalized <- NormalizeData(seurat_obj) %>% 
    FindVariableFeatures(selection.method = 'dispersion', mean.cutoff = c(0.005, 1))
  
  # scale and run clustering
  clustered <- ScaleData(normalized) %>% 
    RunPCA(verbose = FALSE) %>% 
    RunUMAP(dims = 1:30, n.components=3) %>% 
    RunTSNE(dims = 1:30, dim.embed = 3, check_duplicates = FALSE) %>% 
    FindNeighbors(dims = 1:10) %>% 
    FindClusters(resolution = 0.5)
  
  # store normalized and clustered object in a list 
  out <- list(normalized = normalized, clustered = clustered)
  
  return(out)
}


getNumberOfHVG <- function(object, threshold){
  
  #### Number of variable features  
  # Here we find the number of variable features with various cutoffs after quality control. 
  num_hvg <- numeric()
  
  for(i in 1:length(threshold)){
    num_hvg[i] <- as.data.frame(HVFInfo(object = object)) %>% 
      dplyr::select(dispersion.scaled) %>% 
      dplyr::filter(dispersion.scaled > threshold[i]) %>% 
      nrow()
  }
  
  return(num_hvg)
}

```


```{r include=FALSE}

pro_sample <- qc_sample <- HVG_sample <- list()
dispersion_cutoff <- c(0.5, 1.0, 1.5, 2.0, 2.5)
df <- data.frame(dispersion_cutoff)

for(i in 1:length(seurat_qc)){
  pro_sample[[i]] <- process_seurat(seurat_qc[[i]])
  qc_sample[[i]] <- pro_sample[[i]]$normalized
  HVG_sample[[i]] <- getNumberOfHVG(qc_sample[[i]], dispersion_cutoff)
  df <- data.frame(df, HVG_sample[[i]])
  names(df)[i+1] <- paste('HVG', dh_organoid_ids[[i]], sep = '_')
}

```

```{r}

df %>% 
  knitr::kable(caption = 'Table 5: Number of HVG after quality control') %>% 
  kable_styling(full_width = F)

```


## Clustering

Clustering cells and running a DE analysis between clusters can give an idea about different cell populations that may exist in the samples and various gene expression patterns. To better understand the composition of the clusters, we will look into these factors and show them on plots:  

* mitochondrial content (percentage)  
* ribosomal content (percentage)  
* number of detected genes  

0.5 was chosen as a resolution. 

Now let's look at the chosen resolution (0.5) in more detail. We visualize the clusters in a dimensionality reduction plots below. 

#### t-SNE
```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10}

for(i in 1:length(pro_sample)){
  qc_sample[[i]] <- pro_sample[[i]]$clustered
  print(DimPlot(qc_sample[[i]], reduction = "tsne") + ggtitle(dh_organoid_ids[[i]]))
}


```


#### UMAP
```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 10}

for(i in 1:length(pro_sample)){
  print(DimPlot(qc_sample[[i]], reduction = "umap") + ggtitle(dh_organoid_ids[[i]]))
}

```



### Visualize Clusters with Violin PLots

Now, we will look into the contents of these clusters and visualize these values in the violin plots below.  

```{r include = FALSE}

clus_violin <- function(sce, clus_seurat){
  
  # now lets compute the statistics above in plots, for that we need to add the clusters information to the sce objects 
  sample_info_df <- data.frame(clusters=clus_seurat$seurat_clusters, mito_percentage=sce$subsets_mito_percent, 
                               ribo_percentage=sce$subsets_ribo_percent, detected_genes=sce$detected)
  
  # now we make the plots 
  plot_sample_mito <- ggplot(sample_info_df, aes(x = factor(clusters), y = mito_percentage, fill = factor(clusters))) + 
    geom_violin() + 
    geom_jitter(height = 0.1, width = 0.08) + 
    theme_classic() + 
    ggtitle('mitochondrial content')

  plot_sample_ribo <- ggplot(sample_info_df, aes(x = factor(clusters), y = ribo_percentage, fill = factor(clusters))) + 
    geom_violin() + 
    geom_jitter(height = 0.1, width = 0.08) + 
    theme_classic() + 
    ggtitle('ribosomal content') + ylim(0, 40)

  plot_sample_genes <- ggplot(sample_info_df, aes(x = factor(clusters), y = detected_genes, fill = factor(clusters))) + 
    geom_violin() + 
    geom_jitter(height = 0.1, width = 0.08) + 
    theme_classic() + 
    ggtitle('detected genes') + ylim(0, 10000)
  
  p <- list(plot_sample_mito = plot_sample_mito, plot_sample_ribo = plot_sample_ribo, plot_sample_genes = plot_sample_genes)
  
  return(p)
}


```


```{r echo = FALSE, message = FALSE, warning = FALSE, fig.height = 5, fig.width = 18}

sample <- list()

for(i in 1:length(pro_sample)){
  sample[[i]] <- clus_violin(sce_qcs[[i]], pro_sample[[i]]$clustered)
  print(grid.arrange(sample[[i]]$plot_sample_mito, sample[[i]]$plot_sample_ribo, sample[[i]]$plot_sample_genes, nrow = 1,
                     top = dh_organoid_ids[[i]]))
}

```


### Dimension Reduction showing Number of Detected Reads

We can also visualize total number of detected reads on a log-scale with dimension reduction plots. 

```{r include=FALSE}

dim_red_df <- function(sample){
  
  # get pca coordinates 
  pca_1 <- as.numeric(Embeddings(object = sample$clustered, reduction = "pca")[,1])
  pca_2 <- as.numeric(Embeddings(object = sample$clustered, reduction = "pca")[,2])
  pca_3 <- as.numeric(Embeddings(object = sample$clustered, reduction = "pca")[,3])

  # get tsne coordinates 
  tsne_1 <- as.numeric(Embeddings(object = sample$clustered, reduction = "tsne")[,1])
  tsne_2 <- as.numeric(Embeddings(object = sample$clustered, reduction = "tsne")[,2])
  tsne_3 <- as.numeric(Embeddings(object = sample$clustered, reduction = "tsne")[,3])

  # get umap coordinates 
  umap_1 <- as.numeric(Embeddings(object = sample$clustered, reduction = "umap")[,1])
  umap_2 <- as.numeric(Embeddings(object = sample$clustered, reduction = "umap")[,2])
  umap_3 <- as.numeric(Embeddings(object = sample$clustered, reduction = "umap")[,3])

  # add information on number of detected reads on a log scale
  umi_df <- GetAssayData(object = sample$clustered, slot = "counts") %>% colSums() %>% log()

  # make dfs 
  df_tsne <- data.frame(tsne_1, tsne_2, tsne_3)
  df_tsne$cluster <- as.factor(sample$clustered$seurat_clusters)
  df_tsne$reads <- umi_df

  df_pca <- data.frame(pca_1, pca_2, pca_3)
  df_pca$cluster <- as.factor(sample$clustered$seurat_clusters)
  df_pca$reads <- umi_df

  df_umap <- data.frame(umap_1, umap_2, umap_3)
  df_umap$cluster <- as.factor(sample$clustered$seurat_clusters)
  df_umap$reads <- umi_df
  
  df_all <- list(df_pca, df_tsne, df_umap)
  
  return(df_all)
}

dimred_df <- list()
for(i in 1:length(pro_sample)){
  dimred_df[[i]] <- dim_red_df(pro_sample[[i]])
}

```



```{r include=FALSE}

reads_plot <- function(df, dim){
  if(dim==2){
    p <- plot_ly(data = df,
        x = ~df[,1], y = ~df[,2],
        opacity = 1,
        color = ~reads,
        type = "scatter",
        mode = "markers",
        marker = list(size = 3), 
        hovertext = paste("log(Reads):", df$reads)) %>% 
  layout(legend= list(itemsizing='constant'), title=dh_organoid_ids[[i]])
  } else {
    p <- plot_ly(data = df,
        x = ~df[,1], y = ~df[,2], z = ~df[,3],
        opacity = 1,
        color = ~reads,
        type = "scatter3d",
        mode = "markers",
        marker = list(size = 3), 
        hovertext = paste("log(Reads):", df$reads)) %>% 
  layout(legend= list(itemsizing='constant', title=dh_organoid_ids[[i]]))
  }
  return(p)
}


```


#### PCA
```{r}

l2 <- l3 <-  htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- reads_plot(df=dimred_df[[i]][[1]], dim=2)
  l3[[i]] <- reads_plot(df=dimred_df[[i]][[1]], dim=3)
}

l2
l3
```

#### t-SNE
```{r}

l2 <- l3 <-  htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- reads_plot(df=dimred_df[[i]][[2]], dim=2)
  l3[[i]] <- reads_plot(df=dimred_df[[i]][[2]], dim=3)
}

l2
l3
```

#### UMAP
```{r}

l2 <- l3 <-  htmltools::tagList()
for(i in 1:length(pro_sample)){
  l2[[i]] <- reads_plot(df=dimred_df[[i]][[3]], dim=2)
  l3[[i]] <- reads_plot(df=dimred_df[[i]][[3]], dim=3)
}

l2
l3
```




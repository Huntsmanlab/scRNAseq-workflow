---
title: '`r params$ids` DE analysis using edgeR'
author: "aslÄ±"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide

params:
  ids: 'DH25_3-DH25_control_8'
---


```{r include = FALSE}

# source some files / packages 
library(here)
source(here('pipeline', 'sourceFiles', 'utilities.R'))
```

```{r include = FALSE}
# get the ids 
ids <- strsplit(params$ids, "-")[[1]] 

first_sample <- strsplit(ids[[1]], "_")[[1]][[1]]
first_sample_cluster <- as.numeric(strsplit(ids[[1]], "_")[[1]][[2]])
  
second_sample <- paste(strsplit(ids[[2]], "_")[[1]][[1]], strsplit(ids[[2]], "_")[[1]][[2]], sep = '_')
second_sample_cluster <- as.numeric(strsplit(ids[[2]], "_")[[1]][[3]])

dh_organoid_ids <- list(first_sample, second_sample)

# load the sces with the clustering data 
sces <- lapply(dh_organoid_ids, function(dh_organoid_ids) readRDS(here('..', 'DH_organoid', 'data', 'clustered', 'sce', dh_organoid_ids, 'sce_clus.rds')))

# subset those sces based onto the cluster we are interested in. indices of TRUE are the cells that belong to our cluster  
sces1_idx <- which(sces[[1]]@colData[, 'cluster'] == first_sample_cluster)
sces2_idx <- which(sces[[2]]@colData[, 'cluster'] == second_sample_cluster)

# subset the sces to the cells we are interested in 
sces[[1]] <- sces[[1]][, sces1_idx]
sces[[2]] <- sces[[2]][, sces2_idx]

# find the common genes between the sces 
universal <- Reduce(intersect, list(rownames(sces[[1]]), rownames(sces[[2]])))

# only keep the common genes in all counts 
counts(sces[[1]]) <- counts(sces[[1]][universal, ])
counts(sces[[2]]) <- counts(sces[[2]][universal, ])

# put genes in alphabetical order 
counts(sces[[1]]) <- counts(sces[[1]])[order(rownames(counts(sces[[1]]))), ]
counts(sces[[2]]) <- counts(sces[[2]])[order(rownames(counts(sces[[2]]))), ]

# add the sample id to the cell barcodes, just in case the same barcode was used more than once across the two samples
colnames(counts(sces[[1]])) <- paste(first_sample, colnames(counts(sces[[1]])), sep = '_')
colnames(counts(sces[[2]])) <- paste(second_sample, colnames(counts(sces[[2]])), sep = '_')

# now combine the counts into one 
counts <- cbind(counts(sces[[1]]), counts(sces[[2]]))

# design the group. this helps edgeR distinguish where each sample came from. 
group <- factor(c(rep(1, length(sces1_idx)), rep(2, length(sces2_idx))))

# make the DGE object 
dgeObject <- DGEList(counts = counts, genes = rownames(counts), group = group)

# filter the lowly expressed genes - have at least in 0.5 cpm in at least 2 samples 
keep <- rowSums(cpm(dgeObject) > 0.5) >= 2 
dgeObject <- dgeObject[keep, ]

```


```{r include = FALSE}

# make the design matrix 
designMatrix <- model.matrix(~group)

# normalize using edgeR's method 
dgeObject <- calcNormFactors(dgeObject)

# Then estimate the common dispersion from the housekeeping genes and all the libraries as one group
dgeObject <- estimateDisp(dgeObject, design = designMatrix)


```


```{r include = FALSE}
# now that we have the dispersion estimates and the linear model, we will work on DE using quasi-likelihood (QL) F-test. 
# this is better than a regular linear model because it accounts for the uncertainity in the dispersion estimates and gives us more flexibility. 

# first fit a negative binomial model to the data 
fit <- glmQLFit(dgeObject, designMatrix, robust = TRUE)

# the baseline is group one. here, we compare group 2 to group 1. if we had 3 groups and said coef = 3, this would mean comparing group 3 to group1. 
# in other words, here we test the null hypothesis that coef1 - coef2 is equal to zero. 
qlf <- glmQLFTest(fit, coef = 2)

# you can use this piece of code to see the top genes: 
# topTags(qlf) 

# to find genes DE in all the groups: 
# qlf <- glmQLFTest(fit, coef = 2:3)

# DE GENE EXPRESSION ABOVE A THRESHOLD
# Note that the fold-change threshold here is not the minimum value of the fold-change. Genes will need to exceed this threshold
# before being declared statistically significant. we will use the same negative binomial fit but just for this time, add a threshold. 

qlf_threshold <- glmTreat(fit, coef = 2, lfc = 0.5)

# topTags(qlf_threshold)

# Map gene names to entrez ids for goana and kegga. we have to convert from ensembl ids to entrez ids. 
geneIDs <- ensembldb::select(EnsDb.Hsapiens.v75, keys = rownames(qlf), keytype = "SYMBOL", columns = c("SYMBOL","ENTREZID"))

# sometimes we get duplicates, remove those 
geneIDs <- geneIDs[!duplicated(geneIDs$SYMBOL), ]

# lets make sure we have the same genes in both 
idx <- is.na(geneIDs$ENTREZID)
idx_keep <- which(idx == FALSE)
qlf_modified <- qlf[idx_keep, ]

# drop the NAs, these are the genes we couldn't find an entrez id for 
geneIDs <- na.omit(geneIDs)

# do some gene enrichment 
go <- goana(qlf_modified, geneid = geneIDs$ENTREZID, species="Hs") # entrez gene ids are in mapping 

# visualize goana results 
# topGO(go, sort="up") 

keg <- kegga(qlf_modified, geneid = geneIDs$ENTREZID, species="Hs")

# visualize kegga results
# topKEGG(keg, sort="up")

```


```{r include = FALSE}
# NEGATIVE CONTROL - here we mix shuffle the clusters the cells belong to. since they are randomly distributed, this analysis shouldnt return any DE genes. 
sces_neg <- sces

# combine sces 
combined_sces <- combine_sces(sces_neg[[1]], sces_neg[[2]])

# redesign the group. here we shuffle the groups which our cells belongs to. 
group_neg <- sample(group)

# make the dge object
dgeObject_neg <- DGEList(counts = counts(combined_sces), genes = rownames(counts(combined_sces)), group = group_neg)

# filter the lowly expressed genes - have at least in 0.5 cpm in at least 2 samples 
keep <- rowSums(cpm(dgeObject) > 0.5) >= 2 
dgeObject <- dgeObject[keep, ]

# normalize using edgeR's method 
dgeObject_neg <- calcNormFactors(dgeObject_neg)

# estimate the dispersion of genes to prepare for fitting the linear model
designMatrix_neg <- model.matrix(~group_neg)

dgeObject_neg <- estimateDisp(dgeObject_neg, designMatrix_neg)

fit_neg_control <- glmQLFit(dgeObject_neg, designMatrix_neg, robust = TRUE) #  fit a negative binomial model to the data 

qlf_neg_control <- glmQLFTest(fit_neg_control, coef = 2) # QL f test 


```

### Diagnostic Plots 
These plots are intended to give an idea about the model and whether it is a good fit to represent the data we are interested in analyzing. 

Plot cells on a two-dimensional scatterplot so that distances on the plot approximate the expression differences between the cells  
Cells shown far apart mean they that are different in terms of gene expression. Cells shown together are more similar in terms of gene expression.  
```{r include = FALSE}

MDS <- plotMDS(dgeObject)

```


```{r echo = FALSE, message = FALSE, fig.width = 8, fig.height = 6}
plot(MDS, xlab = 'leading fold change in dim2', ylab = 'leading fold change in dim2')

```
#### Plot biological coefficient of variation against gene abundance, in log2 counts per million.  
Biological coefficient of variation is the true variation between genes, and it corresponds to the dispersion parameter of the negative binomial model. To learn more about dispersion, variation and how they relate to one another, read more about the negative binomial model and its implementation in scRNA sequencing data.  
Look for these to make sure your the model is a good fit:  
**1.** High dispersion (variance) for low counts is expected. Dispersion is expected to decrease smoothly as the abundance increases.  
**2.** For humans, common dispersion (the red line) should be around 0.3 - 0.4, meaning replicates can differ by 30% or more. If the common dispersion is more,  
YOU SHOULD NOT BE USING THIS SCRIPT. High dispersion values will influence the differential expression analysis.  

**This plot will give you a measure of the variation between the samples. **
```{r, echo = FALSE, message = FALSE, fig.height = 5, fig.width = 7}
# plot biological coefficient of variation against gene abundance, in ln counts per million 
BCVplot <- plotBCV(dgeObject)
BCVplot
```

#### Plot the genewise quasi-likelihood dispersion against the gene abundance (in log2 counts per million).
In this script, we squeeze the dispersion values from raw counts towards the trended dispersion. (This just means we transform the data in certain ways to make the model fit.)
The plots gives an idea about how much the data was squeezed. The expected is too see squeezed dispersion values (shown in red) closer to the trended (blue) line
```{r,echo = FALSE, message = FALSE, fig.height = 7, fig.width = 7}
# Plot the genewise quasi-likelihood dispersion against the gene abundance (in ln counts per million).
dispersion <- plotQLDisp(fit)
dispersion
```


#### Plot the differentially expressed genes  
The blue lines indicate 1-fold up or down. The number of genes that are significantly up or down regulated are shown in the table, according to the plot.  
```{r echo = FALSE, message = FALSE, fig.height = 10, fig.width = 7}
# plot the differentially expressed genes 
MDplot <- plotMD(qlf, main = paste('differentially expressed genes in', dh_organoid_ids[[2]], 'compared to', dh_organoid_ids[[1]]), ylab = 'log2 fold change')
MDplot
abline(h=c(-1,1), col="blue")
```


Take a closer look at the genes visualized above: 
```{r, echo = FALSE, message = FALSE}
summary <- summary(decideTests(qlf))

summary %>% 
    knitr::kable(caption = paste('comparing', dh_organoid_ids[[2]], 'to', dh_organoid_ids[[1]])) %>% 
    kable_styling(full_width = F)
```


Now we narrow down the DE genes a little bit to visualize genes with a reasonably large expression changes. This is helpful to list the biologically more meaningful genes.  
We restrict the fold change to 0.5.  
```{r echo = FALSE, message = FALSE, fig.height = 10, fig.width = 7}

MDplot2 <- plotMD(qlf_threshold, main = paste('differentially expressed genes in', dh_organoid_ids[[2]], 'compared to', dh_organoid_ids[[1]]), ylab = 'log2 fold change')
MDplot2

```

#### Upregulated genes 
Now we take a closer look at the **upregulated** genes. To look for interesting genes, we do the following filtering:  
We don't show genes with log fold change (LogFC) less than 0.5. 
We also eliminate genes with p values more than 0.05.  
We resticted this table to first 50 genes. 
  
To help interpret, we use the follwing ranking system: 
Genes are ranked separately for log fold change (high to low) and p values (low to high). We then add these ranks together to get **summed_ranks.**  
Genes with smaller summed_ranks have high fold changes and low p values.

```{r echo = FALSE, message = FALSE}

# here we do some manipulation to show the upregulated genes in a meaningful way 
upregulated_genes_table <- make_upreg_table(qlf)%>%
  mutate_at(vars(logFC), funs(round(., 3)))

DT::datatable(upregulated_genes_table,
  extensions = 'Buttons',
  options = list(dom = 'Bfrtip',
                 buttons = list("copy", "excel", "csv", "pdf")))

# # save the table to be loaded later 
write.csv(upregulated_genes_table, file = here('..', 'data', 'dge', 'edgeR_up', paste(params$ids)))

```

#### Downregulated genes 
Filtering and ranking systems is the same as upregulated genes, as explained above. Genes with the highest fold changes and lowest p values have lower summed_ranks.
  
```{r echo = FALSE, message = FALSE}

# here we do some manipulation to show the upregulated genes in a meaningful way 
downregulated_genes_table <- make_downreg_table(qlf) %>% 
  mutate_at(vars(logFC), funs(round(., 3)))

DT::datatable(downregulated_genes_table, 
  extensions = 'Buttons', 
  options = list(dom = 'Bfrtip', 
                 buttons = list("copy", "excel", "csv", "pdf")))

# save the table to be loaded later 
write.csv(downregulated_genes_table, file = here('..', 'data', 'dge', 'edgeR_down', paste(params$ids)))

```


This table tells us how many genes up or down regulated in the analysis with the given log fold change:  
```{r echo = FALSE, message = FALSE}

summary <- summary(decideTests(qlf_threshold))

summary %>% 
    knitr::kable(caption = paste('comparing', dh_organoid_ids[[2]], 'to', dh_organoid_ids[[1]])) %>% 
    kable_styling(full_width = F)

```

### Gene enrichment  
#### GO Pathway analysis  
Understanding the table:  
**Ont:**  
Note that GO shows three complementary biological concepts including Biological Process (BP), Molecular Function (MF) and Cellular Component (CC).  
You can find these in the 'Ont' column.  
**N:**  
number of genes in the GO term  
**Up:**  
number of up-regulated differentially expressed genes.  
**Down:**
number of down-regulated differentially expressed genes.
**P.Up**  
p-value for the representation of GO pathway in up-regulated genes  
**P.Down**  
p-value for the representation of GO pathway in down-regulated genes  
The above is also true for the KEGG table below. 

```{r echo = FALSE, message = FALSE}
# here we show the results of the go pathways 
gotable <- topGO(go, sort="up")

# do some cleaning up
DT::datatable(gotable, 
  extensions = 'Buttons', 
  options = list(dom = 'Bfrtip', 
                 buttons = list("copy", "excel", "csv", "pdf")))
  
```

#### KEGG analysis 

```{r echo = FALSE, message = FALSE}
# here we show the results of the KEGG analysis 
keggtable <- topKEGG(keg, sort="up")

# do some cleaning up
DT::datatable(keggtable, 
  extensions = 'Buttons', 
  options = list(dom = 'Bfrtip', 
                 buttons = list("copy", "excel", "csv", "pdf")))

```

```{r include = FALSE}
# now we make a heatmap to visualize the DE genes 
# convert the read counts into log2-counts-per-million (logCPM) values
logCPM <- cpm(dgeObject, prior.count=2, log=TRUE)
rownames(logCPM) <- dgeObject$genes$Symbol 
colnames(logCPM) <- paste(dgeObject$samples$group, 1:2, sep="-")
```

Negative Control
The plot should return to no / few DE genes. 
```{r echo = FALSE, message = FALSE, fig.height = 5, fig.width = 7}
plotMD(qlf_neg_control)
```


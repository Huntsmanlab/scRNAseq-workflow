import os.path
from snakemake_helper_functions import *

# To make it easy to copy, I added the samples here: 
# 'bgi_175_001-ilm_175_001' 'bgi_176_001-ilm_176_001', 'bgi_176_002-ilm_176_002' 'DH13', 'DH18', 'VOA11229_CCOC', 'DH7', 'DH8'
# 'DH24', 'DH7', 'DH4', 'DH17', 'DH10', 'DH3', 'DH15', 'DH16'

ids = ['DH7'] # separate the ids with a comma 
pair_ids = ['DH7-DH8', 'DH8-DH24'] # separate the pairs with "-", no quotation marks 

ids_integration = ['DH3-DH10-DH8']
ids_dge = ['DH25=DH25_control'] # second id will be compared to first one 

id_type = ['Ovary - Endometrioid']

# FILE NAMES FOR RULE ALL 
path_to_10X = '../data/raw/{id}'
sce_raw = '../data/processed/{id}/sce.rds'

sce_qc = '../data/qc/{id}/sce_qc.rds'
sce_norm = '../data/normalized/{id}/sce_norm.rds'
sce_clus = '../data/clustered/sce/{id}/sce_clus.rds'

# SEURAT INTEGRATION
sce_uncorrected = '../data/integrated/{ids_integration}/uncorrected.rds' # combined, but not integrated (has batch effects)
seurat_integ = '../data/integrated/{ids_integration}/integrated.rds' # integration (batch effects removed)

# MARKDOWN REPORTS
summary_stats_report = '../reports/summary_stats_new/{pair_ids}/summary_stats.html'

sce_clus_report = '../reports/separate_clustering/{id}/separate_clustering.html'

integration_report = expand('../reports/integration/{ids_integration}/integration_report.html', ids_integration = ids_integration) 

combined_clustering_report = '../reports/combined_clustering/{pair_ids}/combined_clustering.html'
combined_clustering_uncorrected = '../data/clustered/combined/{pair_ids}/uncorrected_seurat_object.rds'
combined_clustering_integrated = '../data/clustered/combined/{pair_ids}/integrated_seurat_object.rds'

# paired dge 
paired_dge_output = '../data/dge/paired_dge_basic/{pair_ids}/outputsTEST.rds',
paired_dge_basic_report = '../reports/paired_dge_basic/{pair_ids}/paired_dge_basic.html'
edgeR_report_TWO_samples = '../reports/dge_edgeR/{ids_dge}/dge_analysis_two_samples.html'
edgeR_report_MULTIPLE_samples = '../reports/dge_edgeR/{ids_dge}/dge_analysis_multiple_samples.html'


# CELL ASSIGN
# single sample 
sce_cas = '../data/cellassign/{id}/sce_norm_cas.rds'
sce_cas_integrated = '../data/integrated_cellassign/{ids_integration}/integrated_cas.rds'
marker_mat_path = '../data/cellassign/{id}/marker.mat.rds',
cellassignment_path = '../data/cellassign/{id}/cellassignment.rds',
cellassign_report_single_sample = '../reports/cellassign/{id}/cellassign_report.html'
sce_cas_uncorrected = '../data/integrated_cellassign/{ids_integration}/uncorrected_cas.rds'

# multiple samples 
cellassign_multiple_report = '../reports/cellassign_integrated/{ids_integration}/cellassign_integrated_report.html'

rule all:
  input:
    # expand(sce_raw, id = ids),
    # expand(sce_qc, id = ids),
    # expand(sce_norm, id = ids), 
    # expand(sce_clus, id = ids),
    # expand(sce_clus_report, id = ids),
    # expand(sce_uncorrected, ids_integration = ids_integration), # uncorrected sce before seurat integration
    # expand(seurat_integ, ids_integration = ids_integration) # corrected seurat object after seurat integration
    # integration_report # dim reduction plots before and after batch effect removal
    # expand(combined_clustering_report, pair_ids = pair_ids),
    # expand(combined_clustering_uncorrected, pair_ids = pair_ids),
    # expand(combined_clustering_integrated, pair_ids = pair_ids),
    # batch_correction_output_files(ids)[0], # combined sce with batch effects
    # batch_correction_output_files(ids)[1], # combined sce without batch effects
    # batch_correction_output_files(ids)[2], # batch correction report
    # expand(summary_stats_report, pair_ids = pair_ids),
    expand(edgeR_report_TWO_samples, ids_dge = ids_dge),
    # expand(edgeR_report_MULTIPLE_samples, ids_dge = ids_dge),
    # expand(paired_dge_basic_report, pair_ids = pair_ids),
    # expand(paired_dge_output, pair_ids = pair_ids),
    # expand(sce_cas, id = ids), 
    # expand(marker_mat_path, id = ids), 
    # expand(cellassignment_path, id = ids),
    # expand(cellassign_report_single_sample, id = ids), 
    # expand(sce_cas_integrated, ids_integration = ids_integration), 
    # expand(sce_cas_integrated, ids_integration = ids_integration), 
    # expand(sce_cas_uncorrected, ids_integration = ids_integration)
    
# convert 10X counts to an sce 
rule make_sce:
  input:
    path_to_10X
  output:
    sce_raw
  params:
    "{id}"
  shell:
    "Rscript pipeline/data_preparation/convert_to_sces.R \
     --path_to_10X {input} \
     --output_file_name {output} \
     --id {params} "

# perform quality control on the sce 
rule make_sce_qc:
  params:
    whichMethod = 'default', # to use different parameters here, just update them.
    min_features = 1000,
    mito_thresh_max = 25,
    mito_thresh_min = 1,
    ribo_thresh_max = 60, 
    nmads = 3,
    seed = 1756
  input:
    sce_raw
  output:
    sce_qc
  shell:
    "Rscript pipeline/qc/default_qc.R \
     --whichMethod {params.whichMethod} \
     --path_to_sce {input} \
     --output_file_name {output} \
     --mito_thresh_max {params.mito_thresh_max} \
     --mito_thresh_min {params.mito_thresh_min} \
     --ribo_thresh_max {params.ribo_thresh_max} \
     --nmads {params.nmads} \
     --seed {params.seed} \
     --min_features {params.min_features}"


# normalize the sce by taking log counts and perform dim reduction at the same time
rule normalize_sce:
  params:
    seed = 1756
  input:
    sce_qc
  output:
    sce_norm
  shell:
    "Rscript pipeline/normalization/normalize_sce.R \
     --path_to_QCed_sce {input} \
     --output_file_name {output} \
     --seed {params.seed} "

# cluster the sce alone 
rule cluster_sce:
  params:
    curr_dir = os.getcwd(),
    sample = '{id}'
  input:
    path_to_sce_norm = sce_norm
  output:
    output_path = sce_clus, 
    report = sce_clus_report
  shell:
     "Rscript -e \"rmarkdown::render('pipeline/clustering/separate/clustering.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(id ='{params.sample}', output_path = '{output.output_path}', path_to_sce_norm = '{input.path_to_sce_norm}'))\" "


# integrate (remove batch effects) and cluster 2 sces together 
rule combined_clustering:
  params:
    curr_dir = os.getcwd(), # project directory, parent of this Snakefile
    pair_ids = pair_ids
  input:
    expand(sce_clus, id = ids)
  output:
    report = combined_clustering_report,
    output_uncorrected = combined_clustering_uncorrected,
    output_integrated = combined_clustering_integrated
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/clustering/combined/combined_cluster.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.pair_ids}', output_uncorrected = '{output.output_uncorrected}', output_integrated = '{output.output_integrated}', path_to_sce_clus_list = '{input}'))\" "

    # sce_clus = combined_clustering_report_input_files({pair_ids}) # this gives a list of sce_clus

# lambda wildcards: combined_clustering_report_input_files(wildcards)
rule batch_correction:
  params:
    curr_dir = os.getcwd(), 
    ids = ids, 
    id_type = '{id_type}'
  input:
    batch_correction_input_files(ids)
  output:
    output_uncorrected = batch_correction_output_files(ids)[0],
    output_corrected = batch_correction_output_files(ids)[1],
    report = batch_correction_output_files(ids)[2]
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/batch_normalization/batch_normalization.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', id_type = '{params.id_type}', output_uncorrected = '{output.output_uncorrected}', \
     output_corrected = '{output.output_corrected}', path_to_sce_clus = list('{input}')))\" "

rule make_summary_stats:
  params:
    curr_dir = os.getcwd(),
    pair_ids = pair_ids
  input:
    sce_raw = lambda wildcards: summary_stats_files(wildcards)[0], # automatically assigns pair ids as wildcards 
    sce_qc = lambda wildcards: summary_stats_files(wildcards)[1]
  output:
    report = summary_stats_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/summary_stats/summary_stats_new.Rmd',\
     output_file = '{params.curr_dir}/{output.report}', \
     knit_root_dir = '{params.curr_dir}',\
     params = list(pair_ids = '{params.pair_ids}', path_to_sce_raw = '{input.sce_raw}', path_to_sce_qc = '{input.sce_qc}'))\" "
    
rule seurat_integration:
  params:
    ids_integration = '{ids_integration}', 
  input:
    sce_qc = lambda wildcards: seurat_integration_input_files(wildcards)[0],
    sce_norm = lambda wildcards: seurat_integration_input_files(wildcards)[1]
  output:
    output_file_name_uncorrected = sce_uncorrected,
    output_file_name_integrated = seurat_integ
  shell:
    "Rscript pipeline/seurat_integration/integration.R \
     --path_to_sce_qc {input.sce_qc} \
     --path_to_sce_norm {input.sce_norm} \
     --output_file_name_uncorrected {output.output_file_name_uncorrected} \
     --output_file_name_integrated {output.output_file_name_integrated} \
     --ids_integration {params.ids_integration} "

# show dim reduction plots before and after batch effect removal. 
rule integration_report: 
  params: 
    curr_dir = os.getcwd(),
    ids = ids_integration, 
    id_type = id_type 
  input:
    sce_uncorrected = seurat_integration_output_files(ids)[0], # these objects will be computed by the multiple integration rule, just above  
    seurat_integ = seurat_integration_output_files(ids)[1]
  output:
    report = seurat_integration_report_path(ids)
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/seurat_integration/integration_report.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', id_type = '{params.id_type}', \
     path_to_uncorrected = '{input.sce_uncorrected}', path_to_integrated = '{input.seurat_integ}'))\" "
     

# compute dge analysis across TWO samples using edgeR 
rule edgeR_basic_TWO_samples:
  params:
    curr_dir = os.getcwd(),
    ids = '{ids_dge}', 
  input:
    sce_clus = edgeR_input_files(ids_dge)[1]
  output:
    report = edgeR_report_TWO_samples
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/paired_dge/edgeR_basic_TWO_samples.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', sce_clus = '{input.sce_clus}'))\" "


rule edgeR_basic_MULTIPLE_samples:
  params:
    curr_dir = os.getcwd(),
    ids = '{ids_dge}', 
  input:
    seurat_integ = lambda wildcards: edgeR_input_files(ids_dge)[0]
  output:
    report = edgeR_report_MULTIPLE_samples
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/paired_dge/edgeR_basic_MULTIPLE_samples.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', seurat_integ = '{input.seurat_integ}'))\" "


# compute dge analysis in two samples using scran      
# to do: fix the error, script doesnt run 
rule paired_dge_basic: 
  params: 
    curr_dir = os.getcwd(),
    ids = '{pair_ids}'
  input:
    sce_clus = lambda wildcards: paired_dge_input_files(wildcards)
  output:
    output_path_paired = paired_dge_output,
    report = paired_dge_basic_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/paired_dge/paired_dge_basic.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}', \
     params = list(ids ='{params.ids}', sce_clus = '{input.sce_clus}', output_path_paired = '{output.output_path_paired}'))\" "

# run cell assign in a single sample 
rule run_cellassign: 
  params: 
    mode = 'split_epithelial' # or nosplit epithelial 
  input: 
    sce_norm
  output: 
    sce_cas = sce_cas, 
    marker_mat_path = marker_mat_path, 
    cellassignment_path = cellassignment_path
  shell:
    "Rscript pipeline/cellassign/run_cellassign.R \
     --sce_norm {input} \
     --mode {params.mode} \
     --sce_cas {output.sce_cas} \
     --marker_mat_path {output.marker_mat_path}\
     --cellassignment_path {output.cellassignment_path}"
     

# make report of cell assign run in a single sample.
# if you wish to visualize a few samples together, use the next rule! 
rule cellassign_report: 
  params: 
    curr_dir = os.getcwd(),
    sample = ids
  input: 
    sce_norm = sce_norm, 
    sce_cas = sce_cas
  output:
    report = cellassign_report_single_sample
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/cellassign/cellassign_report.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(sample ='{params.sample}', sce_norm = '{input.sce_norm}', sce_cas = '{input.sce_cas}'))\" "
     
     
rule integrate_cellassign:
  params:
    curr_dir = os.getcwd(),
    ids = '{ids_integration}'  # you can integrate more than two samples even though it says 'pair'
  input:
    path_to_sce_cas = lambda wildcards: integrate_cell_assign_files(wildcards)[0]
  output:
    integrated_object_name = sce_cas_integrated,
    path_to_combined_sce = sce_cas_uncorrected
  shell:
    "Rscript pipeline/cellassign/integrate_cell_assign.R \
     --path_to_sce_cas {input.path_to_sce_cas} \
     --integrated_object_name {output.integrated_object_name} \
     --path_to_combined_sce {output.path_to_combined_sce} \
     --ids_integration {params.ids} "


# this one will visualize results from multiple samples in the same report. consistent colors are used for cell types
rule cellassign_report_multiple_samples:
  params:
    curr_dir = os.getcwd(),
    ids_integration = '{ids_integration}', # you can have more than one cell sample here even though it says 'pair'
    id_type = id_type
  input:
    sce_cas_list = lambda wildcards: cell_assign_multiple_report_files(wildcards)[0], 
    uncorrected_object = lambda wildcards: cell_assign_multiple_report_files(wildcards)[1], 
    integrated_object = lambda wildcards: cell_assign_multiple_report_files(wildcards)[2]
  output:
    report = cellassign_multiple_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/cellassign/integration_report_cellassign.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids_integration = '{params.ids_integration}', id_type = '{params.id_type}', sce_cas_list = '{input.sce_cas_list}', uncorrected_object = '{input.uncorrected_object}', integrated_object = '{input.integrated_object}'))\" "


  

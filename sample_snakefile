import os.path
from snakemake_helper_functions import *

# ids = "DH3"


ids = ['DH21_NEW', 'DH21_control']
#ids = ['DH22_NEW', 'DH22_control']
#ids = ['DH30_GC_C134WFOXL2_new', 'DH30_GC_C134WFOXL2_new']
ids = ['YW1']

# separate samples by '-'
#pair_ids =  ['DH30_GC_wtFOXL2_new-DH30_GC_C134WFOXL2_new']
pair_ids = ['DH21_NEW-DH21_control']
#pair_ids = ['DH22_NEW-DH22_control']
pair_ids = ['YW1']

ids_integration = ['DH21_NEW-DH21_control']
#ids_integration = ['DH22_NEW-DH22_control']
#ids_integration = ['DH30_GC_wtFOXL2_new-DH30_GC_C134WFOXL2_new']

ids_dge = ['VOA10819UT_control_TOP=VOA10819UT_control_BOTTOM', 'VOA10286UT_control_TOP=VOA10286UT_control_BOTTOM'] # second id will be compared to first one

id_type = []

# This function generates a wildcard for the common dges rule. No need to change anything here. 
make_wildcard = lambda some_list: "=".join(some_list)
common_dge_wildcard = make_wildcard(pair_ids)

# FILE NAMES FOR RULE ALL 
path_to_10X = '../huntsmandata/raw/{id}' # where we keep the 10X outputs

sce_norm = '../data/normalized/{id}/sce_norm.rds' # normalized sce
sce_red = '../data/dim_reduction/{id}/sce_red.rds'# sce after dim reduction
dm_path = '../data/dim_reduction/{id}/dm.rds'# diff map coordinates  

sce_clus = '../data/clustered/sce/{id}/sce_clus.rds' # clustered sce 
sce_epith = '../data/epithelial_cells_only/{id}/sce.rds' # sce with epithelial cells only


# BATCH CORRECTION 
path_to_batch_report = '../reports/batch_normalization/{ids_integration}/batch_correction.html'
scran_corrected = '../data/batch_corrected/{ids_integration}/scran_corrected.rds'
seurat_corrected = '../data/batch_corrected/{ids_integration}/seurat_corrected.rds'

# MARKDOWN REPORTS
summary_stats_report = '../reports/summary_stats_new/{pair_ids}/summary_stats.html'
dimRed_report = '../reports/dim_reduction/{id}/dim_reduction.html'
cell_cycle_report = '../reports/cell_cycle/{pair_ids}/cell_cycle_report.html'

sce_clus_report = '../reports/separate_clustering/{id}/separate_clustering.html'
combined_clustering_report = '../reports/combined_clustering/{pair_ids}/combined_clustering.html'
combined_clustering_uncorrected = '../data/clustered/combined/{pair_ids}/uncorrected_seurat_object.rds'
combined_clustering_integrated = '../data/clustered/combined/{pair_ids}/integrated_seurat_object.rds'

# paired dge 
paired_dge_output = '../data/dge/paired_dge_basic/{pair_ids}/outputsTEST.rds',
paired_dge_basic_report = '../reports/paired_dge_basic/{pair_ids}/paired_dge_basic.html'
edgeR_report_TWO_samples = '../reports/dge_edgeR/{ids_dge}/dge_analysis_two_samples.html'
edgeR_report_MULTIPLE_samples = '../reports/dge_edgeR/{ids_dge}/dge_analysis_multiple_samples.html'

# common dges 
common_dge_report = '../reports/common_dges/' + common_dge_wildcard + '/common_dges.html'
common_dge_outfile_name = '/huntsman/amunzur/data/dge/common/' + common_dge_wildcard + '/common_top_genes.csv'
common_dge_plot_file_name = '/huntsman/amunzur/data/dge/common/' + common_dge_wildcard + '/plots.png'

# CELL ASSIGN
sce_cas_path = '../data/cellassign/{id}/sce_norm_cas.rds'
cell_type_csv = '../data/cellassign/{id}/cell_types.csv'

#sce_cas_integrated = '../data/integrated_cellassign/{ids_integration}/integrated_cas.rds'
#sce_cas_uncorrected = '../data/integrated_cellassign/{ids_integration}/uncorrected_cas.rds'


# CELL CYCLE
sce_cell_cycle = '../data/cell_cycle/{id}/cell_cycle_label.rds' # with cell cycle gene label
sce_cell_cycle_corrected = '../data/cell_cycle/{id}/cell_cycle_corrected.rds' # corrected for cell cycle effect


# multiple samples 
cellassign_multiple_report = '../reports/cellassign_integrated/{ids_integration}/cellassign_integrated_report.html'

# velocity: convert seurat to loom
path_to_loom_file = '../data/loom_cas/{id}/seurat_cas.loom'
path_to_barcode_tsv = '../data/loom_cas/{id}/filtered_barcode.tsv'

##########################################
# user friendly naming 

# normalize an sce 
normalize_sce =  expand(sce_norm, id = ids)

# perform dim reduction in sce 
perform_dim_reduction = [expand(sce_red, id = ids), expand(dimRed_report, id = ids)]

# cluster an sce
cluster_sce = [expand(sce_clus, id = ids), expand(sce_clus_report, id = ids)]


# CELL ASSIGN
integrate_cell_assign_results = [expand(cellassign_multiple_report, ids_integration = ids_integration)]

# cell cycle
#run_cell_cycle_assignment = [expand(sce_clus, id = ids), expand(cell_cycle_path, id = ids)]
run_cell_cycle_report = [expand(cell_cycle_report, pair_ids = pair_ids)]

# PAIRED DGE BASIC 
DGE_scran = [expand(paired_dge_basic_report, pair_ids = pair_ids), expand(paired_dge_output, pair_ids = pair_ids)]

# common dges 
find_common_dges = [common_dge_report, common_dge_outfile_name, common_dge_plot_file_name]

# edgeR
DGE_edgeR_TWO_samples = expand(edgeR_report_TWO_samples, ids_dge = ids_dge)

DGE_edgeR_MULTIPLE_samples = expand(edgeR_report_MULTIPLE_samples, ids_dge = ids_dge)

# summary statistics
run_summary_stats = expand(summary_stats_report, pair_ids = pair_ids)

# batch correction 
do_batch_correction = [expand(path_to_batch_report, ids_integration = ids_integration), expand(scran_corrected, ids_integration = ids_integration), expand(seurat_corrected, ids_integration = ids_integration)]

# combined cluster
cluster_two_samples = [expand(combined_clustering_report, pair_ids = pair_ids), expand(combined_clustering_uncorrected, pair_ids = pair_ids), expand(combined_clustering_integrated, pair_ids = pair_ids)]

# velocity
seurat_to_loom = [expand(sce_cas_path, id = ids), expand(path_to_loom_file, id = ids), expand(path_to_barcode_tsv, id = ids)]

process_qc_normalization = expand(sce_norm, id = ids)
dimred_cluster = expand(sce_clus, id = ids)
compute_diff_map = expand(dm_path, id = ids)

#########################################################################################

rule all:
  input:
    #process_qc_normalization,
    run_summary_stats,
    # dimred_cluster,
    # compute_diff_map,
    # do_batch_correction,
    # integrate_cell_assign_results,
    # run_cell_cycle_report,
    # DGE_scran,
    # DGE_edgeR_TWO_samples,
    # DGE_edgeR_MULTIPLE_samples,
    # seurat_to_loom

    ## perform_dim_reduction, # determine number of PCs to use
    ## cluster_sce, #clustering on dividual sample
    ## cluster_two_samples, #clustering on integrated sample
    ## find_common_dges, # common differentially expressed genes in a paired sample



# output normalized sce from 10X:
rule process_qc_normalization: 
  input: 
    path_to_10X
  output: 
    sce_norm
  params: 
    id = "{id}", # wildcard here 
    whichMethod = 'default', # to use different parameters here, just update them.
    min_features = 1000,
    mito_thresh_max = 60,
    mito_thresh_min = 1,
    ribo_thresh_max = 60, 
    nmads = 3,
    remove_mito_and_ribo = "yes" # "yes" will remove all mito and ribo genes, "no" will retain them both in the sce
  shell:
      "Rscript pipeline/process_qc_normalization/process_qc_normalization.R \
     --path_to_10X {input} \
     --id {params.id} \
     --whichMethod {params.whichMethod} \
     --min_features {params.min_features} \
     --output_file_name {output} \
     --mito_thresh_max {params.mito_thresh_max} \
     --mito_thresh_min {params.mito_thresh_min} \
     --ribo_thresh_max {params.ribo_thresh_max} \
     --nmads {params.nmads} \
     --remove_mito_and_ribo {params.remove_mito_and_ribo}"

rule make_summary_stats:
  params:
    curr_dir = os.getcwd(),
    pair_ids = pair_ids,
    whichMethod = 'default', # to use different parameters here, just update them.
    min_features = 1000,
    mito_thresh_max = 60,
    mito_thresh_min = 1,
    ribo_thresh_max = 60, 
    nmads = 3,
    remove_mito_and_ribo = "yes" # "yes" will remove all mito and ribo genes, "no" will retain them both in the sce
  input:
    path_to_10X= expand(path_to_10X, id = ids)
  output:
    report = summary_stats_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/summary_stats/summary_stats_new.Rmd',\
     output_file = '{params.curr_dir}/{output.report}', \
     knit_root_dir = '{params.curr_dir}',\
     params = list(pair_ids = '{params.pair_ids}', whichMethod = '{params.whichMethod}', min_features = '{params.min_features}',\
     mito_thresh_max = '{params.mito_thresh_max}', mito_thresh_min = '{params.mito_thresh_min}', ribo_thresh_max = '{params.ribo_thresh_max}',\
     nmads = {params.nmads}, remove_mito_and_ribo = '{params.remove_mito_and_ribo}', path_to_10X = '{input.path_to_10X}'))\" "

# output clustered sce:
rule dimred_cluster: 
  input: 
    sce_norm
  output: 
    sce_clus
  params: 
    id = "{id}", # wildcard here
    HVG = "no",
    top_HVG = 20, 
    top_PCs = 200, 
    k_value = 15
  shell:
    "Rscript pipeline/dimred_cluster/dimred_cluster.R \
       --path_to_sce_norm {input} \
       --output_file_name {output} \
       --HVG {params.HVG} \
       --top_HVG {params.top_HVG} \
       --top_PCs {params.top_PCs} \
       --k_value {params.k_value}"
       
# output diffusion map coordinates:
rule compute_diff_maps: 
  input: 
    sce_clus
  output: 
    dm_path
  shell:
    "Rscript pipeline/dimred_cluster/dim_reduction/compute_diff_maps.R \
       --sce_clus {input} \
       --dm_path {output}"


# Dim reduction plots on samples before and after batch correction with scran and seurat method:
rule batch_correction:
  params:
    curr_dir = os.getcwd(), 
    ids = ids_integration, 
    id_type = id_type
  input:
    sce_clus = expand(sce_clus, id = ids)
  output:
    report = path_to_batch_report,
    output_corrected = scran_corrected,
    output_integrated = seurat_corrected
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/batch_normalization/batch_normalization.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', id_type = '{params.id_type}', path_to_sce_clus = '{input.sce_clus}',\
     output_integrated = '{output.output_integrated}', output_corrected = '{output.output_corrected}'))\" "
 
 
rule cellassign_report_multiple_samples:
  params:
    curr_dir = os.getcwd(),
    ids_integration = ids_integration, 
    id_type = id_type,
    sample_type = "other",
    cell_type_csv = expand(cell_type_csv, id = ids)
  input:
    sce_clus = expand(sce_clus, id = ids),
    seurat_corrected = seurat_corrected,
    scran_corrected = scran_corrected
  output:
    report = cellassign_multiple_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/cellassign/scripts/integration_report_cellassign.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids_integration = '{params.ids_integration}', id_type = '{params.id_type}', sample_type = '{params.sample_type}', sce_clus = '{input.sce_clus}', cell_type_csv = '{params.cell_type_csv}', seurat_corrected = '{input.seurat_corrected}', scran_corrected = '{input.scran_corrected}'))\" "

  
rule cell_cycle_report: 
  params: 
    curr_dir = os.getcwd(),
    pair_ids = pair_ids, 
    cell_cycle_species = "human",
    sce_cell_cycle = expand(sce_cell_cycle, id = ids),
    sce_cell_cycle_corrected = expand(sce_cell_cycle_corrected, id = ids)
  input:
    sce_clus = expand(sce_clus, id = ids)
  output:
    report = cell_cycle_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/cell_cycle/cell_cycle_report.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(pair_ids ='{params.pair_ids}', cell_cycle_species = '{params.cell_cycle_species}', sce_clus = '{input.sce_clus}', sce_cell_cycle = '{params.sce_cell_cycle}', sce_cell_cycle_corrected = '{params.sce_cell_cycle_corrected}'))\" "


rule seurat_to_loom:
  input: 
    sce_cas_path
  output:
    path_to_loom_file = path_to_loom_file,
    path_to_barcode_tsv = path_to_barcode_tsv
  shell:
    "Rscript pipeline/velocity/seurat_cas.R \
    --sce_cas_path {input} \
    --path_to_loom_file {output.path_to_loom_file} \
    --path_to_barcode_tsv {output.path_to_barcode_tsv}"
    
    

# compute dge analysis across TWO samples using edgeR 
rule edgeR_basic_TWO_samples:
  params:
    curr_dir = os.getcwd(),
    ids = '{ids_dge}' #'{ids_dge}', 
  input:
    sce_clus = edgeR_input_files_TWO_samples(ids_dge, sce_clus)
  output:
    report = edgeR_report_TWO_samples
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/paired_dge/edgeR_basic_TWO_samples.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', sce_clus = '{input}'))\" "
     
rule edgeR_basic_MULTIPLE_samples:
  params:
    curr_dir = os.getcwd(),
    ids = '{ids_dge}', 
  input:
    sce_clus = edgeR_input_files_TWO_samples(ids_dge, sce_clus)
  output:
    report = edgeR_report_MULTIPLE_samples
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/paired_dge/edgeR_basic_MULTIPLE_samples.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.ids}', sce_clus = '{input.sce_clus}'))\" "

# compute dge analysis in two samples using scran      
rule paired_dge_basic: 
  params: 
    curr_dir = os.getcwd(),
    ids = '{pair_ids}'
  input:
    sce_norm = lambda wildcards: paired_dge_input_files(wildcards, sce_norm)
  output:
    output_path_paired = paired_dge_output,
    report = paired_dge_basic_report
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/paired_dge/paired_dge_basic.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}', \
     params = list(ids ='{params.ids}', sce_norm = '{input.sce_norm}', output_path_paired = '{output.output_path_paired}'))\" "
     
# find common dges between two paired dge comparisons 
rule find_common_dges:
  params:
    curr_dir = os.getcwd(),
    pair_ids = pair_ids,
    ntop = 2000 # number of top common genes 
  input:
    paired_dge_output = common_dges_input_files(pair_ids)
  output:
    report = common_dge_report,
    common_dge_outfile_name = common_dge_outfile_name,
    common_dge_plot_file_name = common_dge_plot_file_name
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/common_dges/find_common_dges.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}', \
     params = list(pair_ids ='{params.pair_ids}', paired_dge_output = '{input.paired_dge_output}', ntop = '{params.ntop}', common_dge_outfile_name = '{output.common_dge_outfile_name}', common_dge_plot_file_name = '{output.common_dge_plot_file_name}'))\" "


  
  
# integrate (remove batch effects) and cluster 2 sces together 
rule combined_clustering:
  params:
    curr_dir = os.getcwd(), # project directory, parent of this Snakefile
    pair_ids = pair_ids
  input:
    expand(sce_clus, id = ids)
  output:
    report = combined_clustering_report,
    output_uncorrected = combined_clustering_uncorrected,
    output_integrated = combined_clustering_integrated
  shell:
    "Rscript -e \"rmarkdown::render('pipeline/dimred_cluster/clustering/combined/combined_cluster.Rmd',\
     output_file='{params.curr_dir}/{output.report}', \
     knit_root_dir='{params.curr_dir}',\
     params = list(ids ='{params.pair_ids}', output_uncorrected = '{output.output_uncorrected}', output_integrated = '{output.output_integrated}', path_to_sce_clus_list = '{input}'))\" "

# sce_clus = combined_clustering_report_input_files({pair_ids}) # this gives a list of sce_clus
# lambda wildcards: combined_clustering_report_input_files(wildcards)
  
  
